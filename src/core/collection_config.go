package core

import (
	"encoding/json"
	"fmt"
	"github.com/ohohleo/classify/data"
	"github.com/ohohleo/classify/database"
	"github.com/ohohleo/classify/imports"
	"github.com/ohohleo/classify/params"
	"github.com/ohohleo/classify/reference"
	"log"
)

type CollectionConfig struct {
	Database struct {
		Enable bool `json:"enable"`
	} `json:"database"`

	Buffer struct {
		Enable bool `json:"enable"`
		Size   int  `json:"size"`
	} `json:"buffer"`

	Import struct {
		Filters    reference.StringList `json:"filters" kind:"stringlist"`
		Separators reference.StringList `json:"separators" kind:"stringlist"`
		Banned     reference.StringList `json:"banned" kind:"stringlist"`
	} `json:"import"`

	Datas data.Configs `json:"datas"`

	references []*reference.Ref
	params     map[string]params.HasParam
}

func NewCollectionConfig() *CollectionConfig {

	config := &CollectionConfig{
		Datas: make(map[string]data.Config),
	}

	// Default buffer config
	config.Buffer.Size = 2

	return config
}

func (c *CollectionConfig) Get(needReferences bool) interface{} {

	if needReferences {

		if c.references == nil {
			c.references, c.params = reference.GetParamRefs("datas", c)
		}

		return reference.New(c.references, c)
	}

	return c
}

func (c *CollectionConfig) Update(config []byte) error {
	return json.Unmarshal(config, c)
}

func (c *CollectionConfig) AddParam(key string, param params.HasParam) {

	if c.params == nil {
		c.params = make(map[string]params.HasParam)
	}

	c.params[key] = param
}

func (c *CollectionConfig) GetParam(path string, name string, body json.RawMessage) (result interface{}, err error) {

	if c.params == nil {
		err = fmt.Errorf("no config params initialized")
		return
	}

	param, ok := c.params[path]
	if ok == false {
		err = fmt.Errorf("no config params '%s' found", path)
		return
	}

	result, err = param.GetParam(name, body)
	return
}

// Return the current list of datas handled by all the imports of the
// collection
func (c *CollectionConfig) UpdateDatas(i imports.Import) {

	if c.Datas == nil {
		c.Datas = make(map[string]data.Config)
	}

	// For each data generated by each import
	for _, importData := range i.GetDatasReferences() {
		c.updateSingleData("datas", importData, make(map[data.Ref]struct{}))
	}
}

func (c *CollectionConfig) updateSingleData(refParent string, d data.Data, alreadyExisting map[data.Ref]struct{}) {

	// Get data ref name
	refName := d.GetRef().String()
	refParent += "-" + refName

	// Does the data ref already exist
	if _, ok := c.Datas[refName]; ok {
		return
	}

	// Store data config if it exists
	if hasConfig, ok := d.(data.HasConfig); ok {
		if config := hasConfig.NewConfig(); config != nil {
			c.Datas[refName] = config
		}
	}

	if param, ok := d.(params.HasParam); ok {
		c.AddParam(refParent, param)
	}

	alreadyExisting[d.GetRef()] = struct{}{}

	// Check data dependencies
	if hasDeps, ok := d.(data.HasDependencies); ok {

		for _, dep := range hasDeps.GetDependencies() {

			if _, ok := alreadyExisting[dep.GetRef()]; ok {
				log.Fatalf("Invalid circular data dependencies : %s\n", refName)
			}

			c.updateSingleData(refParent, dep, alreadyExisting)
		}
	}
}

func (c *CollectionConfig) Store2DB(collection *Collection, db *database.Database) error {

	// Convert to JSON
	configStr, err := json.Marshal(c)
	if err != nil {
		return err
	}

	// Update the collection config
	return db.Update("collections", &database.GenStruct{
		Name:   collection.Name,
		Ref:    uint64(collection.engine.GetRef()),
		Config: configStr,
	}, []string{"config"}, "name = :name AND ref = :ref")
}
